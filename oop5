#include <iostream>
#include <vector>
#include <windows.h>

using namespace std;

class Base {
public:
    void novirtual_method() {
        cout << "не виртуальный метод класса Base" << endl;
    }

    virtual void virtual_method() {
        cout << "виртуальный метод класса Base" << endl;
    }

    void callsmethod1() {
        cout << "Вызван: ";
        novirtual_method();
    }

    virtual void callsmethod2() {
        cout << "Вызван: ";
        virtual_method();
    }

    virtual ~Base() {
        cout << "Вызван деструктор Base" << endl;
    }
};

class Dec : public Base {
public:
    void novirtual_method() {
        cout << "перекрываемый не виртуальный метод класса Dec" << endl;
    }

    void virtual_method() override {
        cout << "переопределяемый виртуальный метод класса Dec" << endl;
    }
};

class Base2 {
public:
    virtual string classname() {
        return "Base2";
    }

    virtual bool isA(const string& classname) {
        return classname == "Base2";
    }

    virtual ~Base2() = default;
};

class Dec2 : public Base2 {
public:
    string classname() override {
        return "Dec2";
    }

    bool isA(const string& classname) override {
        return classname == "Dec2" || Base2::isA(classname);
    }
};

class Base3 {
public:
    Base3() { cout << "Конструктор Base3 по умолчанию" << endl; }
    Base3(Base3* obj) { cout << "Конструктор Base3 копирования указателей" << endl; }
    Base3(Base3& obj) { cout << "Конструктор Base3 копирования ссылок" << endl; }
    ~Base3() { cout << "Деструктор Base3" << endl; }
};

class Dec3 : public Base3 {
public:
    Dec3() { cout << "Конструктор Dec3 по умолчанию" << endl; }
    Dec3(Dec3* obj) { cout << "Конструктор Dec3 копирования указателей" << endl; }
    Dec3(Dec3& obj) { cout << "Конструктор Dec3 копирования ссылок" << endl; }
    ~Dec3() { cout << "Деструктор Dec3" << endl; }
};

void func1(Base3 obj) { cout << "func1 по значению" << endl; }
void func2(Base3* obj) { cout << "func2 по указателю" << endl; }
void func3(Base3& obj) { cout << "func3 по ссылке" << endl; }

// Возврат объектов из функций
class Base4 {
public:
    Base4() { cout << "Конструктор Base4 по умолчанию" << endl; }
    Base4(const Base4&) { cout << "Конструктор Base4 копирования" << endl; }
    ~Base4() { cout << "Деструктор Base4" << endl; }
};

Base4 func1_ret() {
    Base4 locobj;
    return locobj;
}

Base4* func2_ret() {
    Base4 locobj;
    return &locobj;  // Опасное возвращение указателя на локальный объект!
}

Base4& func3_ret() {
    Base4 locobj;
    return locobj;  // Опасное возвращение ссылки на локальный объект!
}

Base4* func4_ret() {
    Base4* dynamicobj = new Base4();
    return dynamicobj;  // Безопасно, но нужно не забыть delete
}

int main() {
    SetConsoleCP(1251);
    SetConsoleOutputCP(1251);

    cout << "1. Прямой вызов объектов" << endl;
    Base base;
    Dec dec;

    cout << "Вызван ";
    base.novirtual_method();

    cout << "Вызван ";
    dec.novirtual_method();

    cout << "\n2. Вызов объектов через указатель" << endl;
    Base* baseptr = &dec;

    cout << "Вызван ";
    baseptr->novirtual_method();

    cout << "Вызван ";
    baseptr->virtual_method();

    cout << "\n3. Вызовы методов внутри методов" << endl;
    dec.callsmethod1();
    dec.callsmethod2();

    cout << "\n4. Демонстрация виртуального деструктора" << endl;
    Base* newobject = new Dec();
    delete newobject;

    cout << "\n5. Ручная проверка типа" << endl;
    vector<Base2*> obj = { new Base2(), new Dec2() };

    for (auto& objects : obj) {
        cout << "classname: " << objects->classname();
        cout << ", isA('Dec2'): " << (objects->isA("Dec2") ? "true" : "false") << endl;
    }

    cout << "\n6. Проблемы с именем класса" << endl;
    Base2* baseAsDec2 = new Dec2();
    cout << "Base2* указывает на Dec2: " << baseAsDec2->classname() << endl;

    cout << "\n7. Безопасное приведение с помощью dynamic_cast" << endl;
    for (auto& objects : obj) {
        Dec2* decPtr = dynamic_cast<Dec2*>(objects);
        if (decPtr) {
            cout << "Объект Dec2, можно безопасно использовать методы Dec2" << endl;
        }
        else {
            cout << "Объект Dec2 не описан" << endl;
        }
    }

    for (auto& objects : obj) delete objects;
    delete baseAsDec2;

    cout << "\n8. Передача объекта Base3 в функции" << endl;
    Base3 base3;
    func1(base3);
    func2(&base3);
    func3(base3);

    cout << "\n9. Передача объекта Dec3 в функции" << endl;
    Dec3 dec3;
    func1(dec3);
    func2(&dec3);
    func3(dec3);

    cout << "\n10. Возврат объектов из функций" << endl;
    cout << "func1_ret - локальный объект по значению:" << endl;
    Base4 b1 = func1_ret();

    cout << "\nfunc2_ret - локальный объект по указателю (опасно!):" << endl;
    Base4* b2 = func2_ret();

    cout << "\nfunc4_ret - динамический объект по указателю:" << endl;
    Base4* b4 = func4_ret();
    delete b4;

    return 0;

    return 0;
}
